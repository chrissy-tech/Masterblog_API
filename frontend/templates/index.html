<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Master Blog Viewer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tailwind Configuration: Use Inter Font -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        /* Basic styling for a pleasant reading experience */
        body {
            background-color: #f8f8f8;
        }
        .post-card {
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .post-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        /* Modal backdrop styling */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.5);
        }
        /* Hide modal by default */
        .modal-container.hidden {
            display: none;
        }
    </style>
</head>
<body class="font-sans antialiased text-gray-800">

    <div class="min-h-screen flex flex-col items-center">
        <!-- Header -->
        <header class="w-full bg-white shadow-md p-6 sticky top-0 z-10">
            <div class="max-w-4xl mx-auto flex justify-between items-center">
                <h1 class="text-3xl font-extrabold text-indigo-700">Masterblog</h1>
                <p class="text-sm text-gray-500">API Status: <span id="apiStatus" class="font-bold"></span></p>
            </div>
        </header>

        <!-- Main Content Area -->
        <main class="max-w-4xl w-full p-6 space-y-8">

            <!-- New Post Form (Added) -->
            <div class="bg-indigo-50 p-6 rounded-xl shadow-lg space-y-4">
                <h2 class="text-xl font-bold text-indigo-700">Add New Post</h2>
                <input type="text" id="postTitle" placeholder="Post Title"
                       class="w-full p-3 border border-indigo-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                <textarea id="postContent" placeholder="Post Content" rows="3"
                          class="w-full p-3 border border-indigo-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-sm resize-none"></textarea>
                <div class="flex justify-end">
                    <button onclick="addPost()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 flex items-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
                        </svg>
                        <span>Add Post</span>
                    </button>
                </div>
            </div>

            <!-- Search and Sort Controls -->
            <div class="bg-white p-4 rounded-lg shadow-lg flex flex-col sm:flex-row gap-4">

                <!-- Search Input -->
                <input type="text" id="searchInput" placeholder="Search title, author, content, or date..."
                       class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-sm">

                <!-- Sort Dropdown -->
                <div class="flex items-center space-x-2">
                    <label for="sortField" class="text-sm font-medium text-gray-700 whitespace-nowrap">Sort by:</label>
                    <select id="sortField" class="p-3 border border-gray-300 rounded-lg text-sm bg-white">
                        <option value="date">Date</option>
                        <option value="id">ID</option>
                        <option value="title">Title</option>
                        <option value="author">Author</option>
                        <option value="content">Content</option>
                    </select>
                </div>

                <!-- Direction Toggle -->
                <button id="sortDirectionToggle" class="p-3 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition duration-150 text-sm font-medium flex items-center justify-center space-x-2">
                    <span id="directionText">Descending</span>
                    <svg id="directionIcon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 transform rotate-180" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M14.707 10.293a1 1 0 010 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 111.414-1.414L10 11.586V3a1 1 0 112 0v8.586l1.293-1.293a1 1 0 011.414 0z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>

            <!-- Posts Container -->
            <div id="postsContainer" class="space-y-6">
                <!-- Blog posts will be injected here by JavaScript -->
                <p class="text-center text-gray-500 mt-10">Loading blog posts...</p>
            </div>

            <!-- Pagination (Placeholder for future use) -->
            <div id="paginationContainer" class="flex justify-center mt-8">
                <!-- Pagination buttons will go here -->
            </div>
        </main>
    </div>

    <!-- Edit Post Modal (NEW) -->
    <div id="editModal" class="modal-container hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
        <div class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-lg mx-4">
            <h2 class="text-2xl font-bold text-indigo-700 mb-6">Edit Blog Post</h2>

            <!-- Hidden Input for Post ID -->
            <input type="hidden" id="editPostId">

            <div class="space-y-4">
                <div>
                    <label for="editTitle" class="block text-sm font-medium text-gray-700 mb-1">Title</label>
                    <input type="text" id="editTitle"
                           class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                </div>
                <div>
                    <label for="editContent" class="block text-sm font-medium text-gray-700 mb-1">Content</label>
                    <textarea id="editContent" rows="5"
                              class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-sm resize-none"></textarea>
                </div>
            </div>

            <div class="flex justify-end space-x-3 mt-6">
                <button onclick="closeEditModal()" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg transition duration-150">
                    Cancel
                </button>
                <button onclick="updatePost()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 flex items-center space-x-2">
                    Save Changes
                </button>
            </div>
        </div>
    </div>
    <!-- End Edit Post Modal -->


    <script>
        // API Configuration: WICHTIG! API-URL auf den korrekten Backend-Port (5002) setzen.
        const API_BASE_URL = 'http://127.0.0.1:5002/api/posts';
        const MAX_RETRIES = 3; // Maximum number of retry attempts

        // State variables for sorting and search
        let currentSortField = 'date'; // Sort by date by default
        let currentDirection = 'desc'; // Descending by default
        let currentSearchTerm = '';

        const postsContainer = document.getElementById('postsContainer');
        const searchInput = document.getElementById('searchInput');
        const sortFieldSelect = document.getElementById('sortField');
        const sortDirectionToggle = document.getElementById('sortDirectionToggle');
        const apiStatusElement = document.getElementById('apiStatus');

        // Input fields for adding a post
        const postTitleInput = document.getElementById('postTitle');
        const postContentInput = document.getElementById('postContent');

        // Modal Elements
        const editModal = document.getElementById('editModal');
        const editPostIdInput = document.getElementById('editPostId');
        const editTitleInput = document.getElementById('editTitle');
        const editContentInput = document.getElementById('editContent');


        // --- MODAL HANDLERS (NEW) ---

        /**
         * Opens the edit modal and pre-fills the form fields with post data.
         * @param {Object} post - The post object to be edited.
         */
        function openEditModal(post) {
            editPostIdInput.value = post.id;
            editTitleInput.value = post.title;
            editContentInput.value = post.content;
            editModal.classList.remove('hidden');
        }

        /**
         * Closes the edit modal.
         */
        function closeEditModal() {
            editModal.classList.add('hidden');
        }


        // --- CRUD Operations ---

        /**
         * Sends a POST request to add a new post.
         */
        async function addPost() {
            const title = postTitleInput.value.trim();
            const content = postContentInput.value.trim();

            if (!title || !content) {
                // IMPORTANT: Use a custom modal instead of the browser's alert()
                showCustomMessage('Please enter both a title and content for the post.', 'error');
                return;
            }

            try {
                const response = await fetch(API_BASE_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, content })
                });

                if (!response.ok) {
                    throw new Error(`Failed to add post. Status: ${response.status}`);
                }

                // Clear input fields and refresh the post list
                postTitleInput.value = '';
                postContentInput.value = '';

                await fetchAndRenderPosts();
                console.log('Post added successfully.');
            } catch (error) {
                console.error('Error adding post:', error);
                showCustomMessage(`Error adding post: ${error.message}`, 'error');
            }
        }

        /**
         * Sends a PUT request to update an existing post. (NEW)
         */
        async function updatePost() {
            const postId = editPostIdInput.value;
            const title = editTitleInput.value.trim();
            const content = editContentInput.value.trim();

            if (!title || !content) {
                 // IMPORTANT: Use a custom modal instead of the browser's alert()
                showCustomMessage('Title and content cannot be empty.', 'error');
                return;
            }

            try {
                const url = `${API_BASE_URL}/${postId}`;
                const response = await fetch(url, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, content }) // Only sending updated fields
                });

                if (!response.ok) {
                    throw new Error(`Failed to update post. Status: ${response.status}`);
                }

                closeEditModal();
                await fetchAndRenderPosts();
                console.log(`Post #${postId} updated successfully.`);
            } catch (error) {
                console.error('Error updating post:', error);
                showCustomMessage(`Error updating post: ${error.message}`, 'error');
            }
        }


        /**
         * Sends a DELETE request to remove a post by ID.
         * @param {number} postId - The ID of the post to delete.
         */
        async function deletePost(postId) {
            // NOTE: Replace with a custom modal in a real app.
            if (!confirm(`Are you sure you want to delete post #${postId}?`)) {
                return;
            }

            try {
                // IMPORTANT: Use the full base URL and append the ID
                const url = `${API_BASE_URL}/${postId}`;
                const response = await fetch(url, { method: 'DELETE' });

                if (!response.ok) {
                    throw new Error(`Failed to delete post. Status: ${response.status}`);
                }

                await fetchAndRenderPosts();
                console.log(`Post #${postId} deleted successfully.`);
            } catch (error) {
                console.error('Error deleting post:', error);
                showCustomMessage(`Error deleting post: ${error.message}`, 'error');
            }
        }

        /**
         * Simple placeholder for a custom message box (as alert() is forbidden).
         */
        function showCustomMessage(message, type) {
            // In a real application, implement a custom modal or toast notification here.
            const color = type === 'error' ? 'red' : 'green';
            console.log(`[${type.toUpperCase()}] ${message}`);
            // Fallback for simplicity:
            const status = document.createElement('div');
            status.className = `p-4 mt-4 text-center text-${color}-700 bg-${color}-100 rounded-lg shadow-lg`;
            status.textContent = message;
            document.querySelector('main').prepend(status);
            setTimeout(() => status.remove(), 5000); // Remove after 5 seconds
        }


        /**
         * Fetches blog posts from the API and renders them with retry logic.
         */
        async function fetchAndRenderPosts() {
            postsContainer.innerHTML = '<p class="text-center text-indigo-600 font-medium mt-10">Loading blog posts...</p>';

            // Initial status
            apiStatusElement.textContent = 'Connecting...';
            apiStatusElement.classList.remove('text-green-600', 'text-red-600');
            apiStatusElement.classList.add('text-yellow-600');

            // Construct the base URL for the request
            let url = API_BASE_URL;

            // Add search parameters if a search term is present
            if (currentSearchTerm) {
                // If searching, use the search endpoint: /api/posts/search
                url = `${API_BASE_URL}/search?query=${encodeURIComponent(currentSearchTerm)}`;
            } else {
                // If sorting/pagination, use the standard endpoint: /api/posts
                url = `${API_BASE_URL}?sort=${currentSortField}&direction=${currentDirection}`;
            }

            for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
                if (attempt > 0) {
                    // Exponential Backoff: 1s, 2s, 4s delay
                    const delay = 1000 * Math.pow(2, attempt - 1);
                    apiStatusElement.textContent = `Retrying attempt ${attempt + 1}/${MAX_RETRIES} (Waiting ${delay / 1000}s)...`;
                    console.warn(`Waiting ${delay}ms before retry attempt ${attempt + 1}`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }

                try {
                    const response = await fetch(url);

                    if (!response.ok) {
                        // If the server responds but with an error code (e.g., 404/500)
                        if (response.status !== 0 && attempt === MAX_RETRIES - 1) {
                             throw new Error(`Server responded with status: ${response.status}`);
                        } else {
                            // If not the last attempt, try again (if it's a transient error)
                            continue;
                        }
                    }

                    const data = await response.json();

                    // The search endpoint returns { results: [...] }, the standard endpoint returns [...]
                    const posts = data.results || data;

                    renderPosts(posts);
                    apiStatusElement.textContent = 'Online';
                    apiStatusElement.classList.remove('text-yellow-600', 'text-red-600');
                    apiStatusElement.classList.add('text-green-600');
                    return; // Successfully fetched and rendered

                } catch (error) {
                    // Only log the error if it is the last attempt
                    if (attempt === MAX_RETRIES - 1) {
                         console.error('Final error fetching posts after all retries:', error);
                         postsContainer.innerHTML = `
                            <div class="text-center p-8 bg-red-100 border border-red-400 text-red-700 rounded-lg">
                                <h2 class="text-xl font-bold mb-2">API Error (Final)</h2>
                                <p>Could not establish connection to the backend API after ${MAX_RETRIES} attempts.</p>
                                <p class="text-sm mt-2">Error: ${error.message || 'Network Error'}. Please ensure the backend server is running and accessible (e.g., on port 5002).</p>
                            </div>
                        `;
                        apiStatusElement.textContent = 'Offline';
                        apiStatusElement.classList.remove('text-yellow-600', 'text-green-600');
                        apiStatusElement.classList.add('text-red-600');
                    } else {
                        // For "Failed to fetch" (network error) or other errors, try again
                        console.warn(`Error on attempt ${attempt + 1}: ${error.message || 'Network Error'}. Retrying...`);
                    }
                }
            }
        }

        /**
         * Renders the list of posts into the container, including edit and delete buttons.
         * @param {Array} posts - The retrieved list of blog posts.
         */
        function renderPosts(posts) {
            if (posts.length === 0) {
                postsContainer.innerHTML = '<p class="text-center text-gray-500 mt-10 p-4 bg-white rounded-lg shadow-lg">No blog posts found.</p>';
                return;
            }

            const html = posts.map(post => `
                <div class="post-card bg-white p-6 rounded-xl shadow-lg border border-gray-100 relative">
                    <h2 class="text-2xl font-semibold text-indigo-600 mb-2">${post.title}</h2>

                    <!-- Action Buttons (Updated to include Edit) -->
                    <div class="absolute top-4 right-4 flex space-x-2">
                        <!-- Edit Button (NEW) -->
                        <button onclick='openEditModal(${JSON.stringify(post)})' class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-1 px-3 rounded-lg text-xs shadow-md transition duration-150">
                            Edit
                        </button>

                        <!-- Delete Button -->
                        <button onclick="deletePost(${post.id})" class="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-3 rounded-lg text-xs shadow-md transition duration-150">
                            Delete
                        </button>
                    </div>

                    <!-- Author and Date Metadata -->
                    <div class="flex flex-wrap items-center text-sm text-gray-500 mb-4 space-x-4">
                        <div class="flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1 text-indigo-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M5.121 17.804A13.935 13.935 0 0112 16c2.5 0 4.847.655 6.879 1.804M15 10a3 3 0 11-6 0 3 3 0 016 0zm6 3a11.088 11.088 0 01-1.391 4.282c-.576.904-1.31 1.687-2.14 2.247 1.411-.397 2.705-1.074 3.822-2.076z" />
                            </svg>
                            <span>${post.author || 'Unknown Author'}</span>
                        </div>
                        <div class="flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1 text-indigo-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                            </svg>
                            <span>${post.date || 'No Date'}</span>
                        </div>
                        <span class="text-xs text-gray-400">#${post.id}</span>
                    </div>

                    <p class="text-base leading-relaxed text-gray-700">${post.content}</p>
                </div>
            `).join('');

            postsContainer.innerHTML = html;
        }

        // --- Event Listeners ---

        // 1. Change sort field
        sortFieldSelect.addEventListener('change', (e) => {
            currentSortField = e.target.value;
            // Reset the search term when switching to sort
            currentSearchTerm = '';
            searchInput.value = '';
            fetchAndRenderPosts();
        });

        // 2. Toggle sort direction
        sortDirectionToggle.addEventListener('click', () => {
            currentDirection = currentDirection === 'asc' ? 'desc' : 'asc';

            // UI Update
            const directionText = document.getElementById('directionText');
            const directionIcon = document.getElementById('directionIcon');

            directionText.textContent = currentDirection === 'desc' ? 'Descending' : 'Ascending';
            directionIcon.classList.toggle('rotate-180', currentDirection === 'desc');

            // Reset the search term before sorting.
            currentSearchTerm = '';
            searchInput.value = '';

            fetchAndRenderPosts();
        });

        // 3. Search input
        let searchTimer;
        searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimer);
            const term = e.target.value.trim();

            searchTimer = setTimeout(() => {
                currentSearchTerm = term;
                // Disables sorting when searching
                if (currentSearchTerm) {
                    // Reset sorting to default so the search endpoint is used
                    sortFieldSelect.value = 'date';
                    currentSortField = 'date';
                }

                fetchAndRenderPosts();
            }, 300); // 300ms delay for debouncing
        });


        // Initial call
        window.onload = fetchAndRenderPosts;

    </script>
</body>
</html>
